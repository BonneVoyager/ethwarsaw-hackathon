{"version":3,"file":"static/js/995.e7c95df0.chunk.js","mappings":"kXAgFaA,G,QAAAA,WAGX,WAA6BC,IAAkC,eAAlC,KAAQA,SAARA,EADrB,KAAiBC,kBAbC,GAcyC,C,kDAU7D,SACJC,EACAC,EACAC,G,kJAGsB,OADtBC,EAAiBH,G,SACWI,KAAKC,iB,UAA3BC,EAAgB,EAAhBA,KACNH,EAAiBH,GAIY,IAAzBC,EAAcM,OAAW,C,wCACpBH,KAAKI,qBACVC,KAAKC,IAAIR,EAAiBI,EAAgBF,KAAKL,mBAAqB,EACpEO,EAAgB,I,UAOdK,GAAsBC,EAAAA,EAAAA,GAC1BX,EAAcA,EAAcM,OAAS,GAAGM,QAEpCC,EAAiBR,EAAgBF,KAAKL,kBAAoB,IAC5DY,GAAuBG,GAAAA,C,yCAClBV,KAAKI,qBAAqBM,EAAgBR,EAAgB,I,QAK/B,O,UAAMF,KAAKW,cAC7Cf,EACAC,G,QAGyC,OALrCe,EAAAA,EAAAA,KAINb,EAAiBH,G,UACgCI,KAAKI,qBACpDG,EAAsB,EACtBL,EAAgB,G,eAFZW,EAAAA,EAAAA,KAINd,EAAiBH,G,oCACNgB,IAAAA,EAAAA,EAAAA,GAAeC,K,gDAC3B,G,6BAUK,SACJjB,EACAkB,EACAC,EACAjB,G,sJAGsB,OADtBC,EAAiBH,G,SACWI,KAAKC,iB,UAA3BC,EAAgB,EAAhBA,KACNH,EAAiBH,GAIW,IAAxBmB,EAAaZ,OAAW,C,wCACnBH,KAAKgB,eACVF,EACAT,KAAKC,IAAIR,EAAiBI,EAAgBF,KAAKL,mBAAqB,EACpEO,EAAgB,I,UAOdK,GAAsBC,EAAAA,EAAAA,GAC1BO,EAAaA,EAAaZ,OAAS,GAAGc,aAElCP,EAAiBR,EAAgBF,KAAKL,kBAAoB,IAC5DY,EAAsBG,GAAAA,C,yCACjBV,KAAKgB,eAAeF,EAAQJ,EAAgBR,EAAgB,I,QAK9C,O,UAAMF,KAAKkB,kBAChCtB,EACAmB,G,QAgBc,OAlBVI,EAAiB,EAAjBA,KAINpB,EAAiBH,GAIXwB,EAAcL,EACjBD,QAAO,SAAAO,GAAG,OAAIb,EAAAA,EAAAA,GAAQa,EAAIJ,aAAeE,EAAeF,WAA9C,IACVK,KAAI,SAAAD,GAAG,OAAIE,OAAAA,OAAAA,OAAAA,OAAAA,CAAAA,EAAMF,GAAG,CAAEG,SAAS,GAAxB,IAIJC,EACJN,EAAeF,cAAgBS,OAAOC,mBAClCnB,EAAAA,EAAAA,GAAQO,EAAa,GAAGE,aACxBE,EAAeF,Y,UACCjB,KAAKgB,eACzBF,EACAW,EACAvB,EAAgB,G,eAIlB0B,GAPIA,EAAY,EAAZA,MAOkBd,QACpB,SAAAO,GAAG,OACDA,KACCb,EAAAA,EAAAA,GAAQa,EAAIJ,aAAeE,EAAeF,cACzCT,EAAAA,EAAAA,GAAQa,EAAIQ,UAAYV,EAAeU,SAHxC,IAML9B,EAAiBH,G,oCACNwB,IAAAA,EAAAA,EAAAA,GAAgBQ,K,gDAC5B,G,iCAOD,SAAoBE,GAClB9B,KAAKL,kBAAoBmC,CAC1B,G,4BAOa,W,0IACmB,O,SAAM9B,KAAKN,SAASqC,KAAK,mB,cAAlDC,EAAAA,EAAAA,K,mBACCxB,EAAAA,EAAAA,GAAQwB,I,+CAChB,G,kCASa,SACZP,EACAQ,G,qJAEIR,GAAsBQ,GAAAA,C,wCACjB,I,OAGT,IADMC,EAA0B,GACvBC,EAAIV,EAAoBU,EAAIF,EAAkBE,IACrDD,EAAWE,KAAK,CACdC,OAAQ,uBACRC,OAAQ,EAACC,EAAAA,EAAAA,GAAMJ,IAAI,KAMG,O,SAAMnC,KAAKN,SAAS8C,UAAUN,G,cAAlDO,EAAoB,EAApBA,KACAC,EAAaD,EAAkBE,QACnC,SAACC,EAAKC,GAAN,OAAgBD,EAAIE,OAAOD,EAA3B,GACA,I,kBAEKH,EAAWpB,IAAIyB,I,+CACvB,G,2BAOa,SACZnD,EACAC,G,gJAEMmD,EAA0B,GAGvBb,EAAItC,EAAcM,OAAS,E,YAAGgC,GAAK,I,gBAExB,OADZc,EAAWpD,EAAcsC,G,SACPnC,KAAKkD,kBAAiB1C,EAAAA,EAAAA,GAAQyC,EAASxC,S,UAAzD0C,EAAY,EAAZA,KACNpD,EAAiBH,GAGbqD,EAASG,OAASD,EAAUC,KAAAA,C,oDAIhCJ,EAAOZ,KAAKW,EAAgBI,I,QAViBhB,I,gDAYxCa,EAAOK,W,gDACf,G,8BAQa,SAAiBpC,G,6JACtBjB,KAAKN,SAASqC,KAAK,uBAAwB,EAChDQ,EAAAA,EAAAA,GAAMtB,IACN,K,+CAEH,G,+BAYa,SACZrB,EACAmB,G,8IAIgB,O,SAAMf,KAAKkD,kBACzB1C,EAAAA,EAAAA,GAAQO,EAAaA,EAAaZ,OAAS,GAAGc,c,OAD5CkC,EAAY,EAAZA,KAGJpD,EAAiBH,GACRuC,EAAIpB,EAAaZ,OAAS,E,YAAGgC,GAAK,I,oBACnCmB,EAASvC,EAAaoB,IAIjBlB,cAAgBkC,EAAU1C,OAAAA,C,gBACvB,O,UAAMT,KAAKkD,kBAAiB1C,EAAAA,EAAAA,GAAQ8C,EAAOrC,c,QAAvDkC,EAAY,EAAZA,K,WAKEG,EAAOC,YAAcJ,EAAUC,KAAAA,C,yCAC1B,CACLnC,aAAaT,EAAAA,EAAAA,GAAQ8C,EAAOrC,aAC5BY,UAAUrB,EAAAA,EAAAA,GAAQ8C,EAAOzB,Y,QAdeM,I,gDAkBvC,CACLlB,YAAaS,OAAOC,kBACpBE,SAAUH,OAAOC,oB,gDAEpB,G,4BAOiB,SAChBb,EACAW,EACAQ,G,+IAEIR,GAAsBQ,GAAAA,C,wCACjB,I,cAEHuB,EAAWjC,OAAAA,OAAAA,OAAAA,OAAAA,CAAAA,EACZT,GAAM,CACT2C,WAAWlB,EAAAA,EAAAA,GAAMd,GACjBiC,SAASnB,EAAAA,EAAAA,GAAMN,EAAmB,K,kBAE7BjC,KAAKN,SAASqC,KAAK,cAAe,CAACyB,K,+CAC3C,K,EAhSU/D,IAmSb,SAASsD,EAAgBY,GACvB,IAAMX,EAAM,iBAA4CW,GAIxD,cAHOX,EAAOY,uBACPZ,EAAOa,oBACPb,EAAOc,OACPd,CACR,CAEK,SAAUe,EAAeC,GAC7B,OAAOC,EAAOD,GAAQ,SAAAE,GAAK,OAAIA,EAAMd,IAAV,GAC5B,CAEK,SAAUe,EAAWH,GACzB,OAAOC,EAAOD,GAAQ,SAAAE,GAAK,gBAAOA,EAAMX,UAAb,YAA0BW,EAAMrC,SAAhC,GAC5B,CAED,SAASoC,EAAUG,EAAYC,GAC7B,IAAMC,EAAqB,IAAIC,IACzBvB,EAAc,GAQpB,OAPAoB,EAAMI,SAAQ,SAAAC,GACZ,IAAMC,EAAML,EAAOI,GACdH,EAASK,IAAID,KAChBJ,EAASM,IAAIF,GACb1B,EAAOZ,KAAKqC,GAEf,IACMzB,CACR,CAED,IAAM6B,EAAY,IAAIC,MAAM,aACtB,SAAU/E,EAAiBH,GAC/B,GAAIA,IACF,MAAMiF,CAEV,CCtYO,IAAME,EACX,+BAuIWC,EAAAA,SAAAA,I,gIAKX,WACE,IAAMC,EAAQjF,KAAKkF,IAAIC,MAAM,KAC7B,GAAIF,EAAM,KAAOF,EAGjB,OAAIE,EAAM,IAAmB,MAAbA,EAAM,GACbG,EAAwBH,EAAM,SAErC,CAEH,G,qBAMD,WACE,IAAMA,EAAQjF,KAAKkF,IAAIC,MAAM,KAC7B,GAAIF,EAAM,KAAOF,EAGjB,OAAIE,EAAM,IAAmB,MAAbA,EAAM,GACbG,EAAwBH,EAAM,SAErC,CAEH,G,sBAMD,WACE,IAAMA,EAAQjF,KAAKkF,IAAIC,MAAM,KAC7B,GAAIF,EAAM,KAAOF,EAGjB,OAAIE,EAAM,IAAmB,MAAbA,EAAM,GACA,SAAbA,EAAM,QAEb,CAEH,K,EA/CUD,CAxEAK,WAQX,WAAYH,EAAaI,EAAoBC,IAAa,eACxDvF,KAAKsF,SAAWA,EAChBtF,KAAKkF,IAAMA,EACXlF,KAAKuF,KAAOA,EACZvF,KAAKwF,kBAAoB,EACzBxF,KAAKyF,WAAY,CAClB,C,kCAED,WACE,OAAQzF,KAAK0F,MACX,IAAK,KACH,OAAO1F,KAAKoD,KACd,IAAK,SACH,OAAOpD,KAAKc,OACd,QACE,OAAOd,KAAKkF,IAEjB,G,gBAED,WACE,OAAOlF,KAAKkF,IAAIC,MAAM,KAAK,EAC5B,G,gBAED,WACE,IAAMF,EAAQjF,KAAKkF,IAAIC,MAAM,KAC7B,GAAiB,OAAbF,EAAM,GACR,MAAM,IAAIH,MAAM,2BAElB,OAAOG,EAAM,EACd,G,kBAED,WACE,IAAMA,EAAQjF,KAAKkF,IAAIC,MAAM,KAC7B,GAAiB,WAAbF,EAAM,GACR,MAAM,IAAIH,MAAM,2BAElB,IAAMa,EAAUV,EAAM,GAEhBW,EAqFV,SAA2BC,GACzB,GAAa,KAATA,EACF,MAAO,GAGT,OAAOA,EAAKV,MAAM,MAAM7D,KAAI,SAAAwE,GAC1B,GAAc,KAAVA,EACF,MAAO,GAGT,IAAMb,EAAQa,EAAMX,MAAM,KAAK7D,KAAI,SAAAwE,GACjC,MAAiB,SAAVA,EAAmB,KAAOA,CAClC,IAED,OAAwB,IAAjBb,EAAM9E,OAAe8E,EAAM,GAAKA,CACxC,GACF,CArGkBc,CAAkBd,EAAM,IACjCnE,EAAiB,CAAC,EASxB,OAPI8E,EAAOzF,OAAS,IAClBW,EAAO8E,OAASA,GAEdD,GAAuB,MAAZA,IACb7E,EAAO6E,QAAUA,GAGZ7E,CACR,G,sBAED,WAEE,OAAOd,KAAKkF,IAAIc,QAAQ,MAAQ,GADT,CAAC,QAAS,UAAW,UAAW,QACHA,QAAQhG,KAAKkF,MAAQ,CAC1E,K,EA9DUG,IAqJb,SAASD,EAAwBS,GAC/B,GAAa,KAATA,EAAJ,CAIA,IAAMI,EAAYJ,EAAKV,MAAM,KAC7B,OAA4B,IAArBc,EAAU9F,OAAe8F,EAAU,GAAKA,CAH9C,CAIH,CC1LA,IAwBaC,EAAAA,SAAAA,I,6BA0BX,WAAYC,EAAuBC,GAAmB,M,GAAA,eAEpD,IAAMC,EAASC,EAAAA,gBAAAA,UAA0BH,EAAOE,QAG1CE,EAAiBD,EAAAA,gBAAAA,kBAAkCH,EAAOK,SAC1DC,EAAaH,EAAAA,gBAAAA,yBACjBC,EACAF,EACA,OAGIK,EAAW,eAAH,OAAkBC,EAAAA,GAG1BC,EAAK,IAAIC,EAAAA,EAA0B,QAAV,EAAAV,EAAOW,WAAGC,IAAAA,EAAAA,EAAIN,EAAWK,IAAKJ,EAAU,CACrEN,cAAe,OAAAA,QAAa,IAAbA,EAAAA,EAk1BE,qBAAZY,SACI,MAAXA,SACoB,MAApBA,QAAQC,UACiB,MAAzBD,QAAQC,SAASC,KARUC,EAAAA,MAAAA,aAAoCC,YAv0BzDC,EAAgBC,EAAAA,EAAcf,GAtBgB,OAuBpD,cAAMK,EAAWS,IA7CZE,QAAuB,GAUb,EAAAC,yBACf,IAAIC,IAEW,EAAAC,uBAA8C,IAAID,IA8Z3D,EAAAE,cAAgB,SAACzD,GACvB,IAAM0D,EAA4BC,KAAKC,MAAM5D,EAAM2B,MACnD,GA4hBJ,SACE+B,GAEA,OAZF,SACEA,GAEA,OACEG,MAAMC,QAAQJ,IACO,QAApBA,EAAQK,cAAyDC,IAAnCN,EAA4BO,EAE9D,CAKSC,CAAWR,EACpB,CAhiBQS,CAAoBT,GAAzB,CAGA,IAAMU,EAAaV,EAAQtF,OAAOiG,aAC5BC,EAAY,EAAKd,uBAAuBe,IAAIH,GAClD,GAAKE,EAAL,CAGA,IAAMD,EAAe,EAAKf,yBAAyBiB,IAAID,GACvD,GAA4B,kBAAxBD,EAAalG,OAIjB,OAAQkG,EAAajG,OAAO,IAC1B,IAAK,WACH,IAAMoG,EAAuBH,EACvBI,EAAkBf,EAChBgB,EAAkCF,EAAlCE,cAAeC,EAAmBH,EAAnBG,eACf7F,EAAW2F,EAAgBrG,OAA3BU,OACJ4F,EA+gBZ,SACEE,EACA5E,GAEA6E,EAAsBD,EAAY5E,EAAO8E,EAC1C,CAnhBSC,CAA0BJ,EAAgB7F,GACjCsF,IAAeE,EAGxB,EAAKU,qBAAqBV,EAAWxF,EAAQgG,GAG7C,EAAKG,cAAcX,EAAWxF,EAAQgG,GAExC,MAEF,IAAK,OACH,IAAMI,EAAmBb,EACnBc,EAAczB,EACZgB,EAAkCQ,EAAlCR,cAAeC,EAAmBO,EAAnBP,eACf7F,EAAWqG,EAAY/G,OAAvBU,OACJ4F,EAqgBZ,SACEE,EACA5E,GAEA6E,EAAsBD,EAAY5E,EAAOoF,EAC1C,CAzgBSC,CAAsBV,EAAgB7F,GAC7BwF,IAAcF,EACvB,EAAKY,qBAAqBV,EAAWxF,EAAQsG,GAE7C,EAAKH,cAAcX,EAAWxF,EAAQsG,GAlC3C,CALA,CA8CF,EAaO,EAAYE,aAAG,WACrB,EAAK9B,uBAAuB+B,QAC5B,MA0ZJ,WACE,IAAIC,GAAY,EAChB,MAAO,CAAEC,OAAQ,kBAAOD,GAAY,CAAnB,EAA0B9J,YAAa,kBAAM8J,CAAN,EACzD,CA7ZmCE,GAAxBD,EAAR,EAAQA,OAAQ/J,EAAhB,EAAgBA,YAChB,EAAKiK,eAAiBF,EAHI,gBAIC,EAAKnC,yBAAyBsC,UAJ/B,yBAIfvB,EAJe,SAKPwB,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAAA,QAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,sEAEb,OAFa,kBAEP/J,KAAKgK,uBAAuBpK,EAAa2I,GAFlC,sDAIR3I,KACHqK,QAAQC,MAAR,mCAC8B3B,EAAajG,OAAO,GADlD,qDALW,uDALO,EAI1B,IAAK,EAAL,qBAAmE,GAJzC,+BAkB1B,EAAK6H,gBACN,EAuFO,EAAwBC,yBAAG,WACD,MAA5B,EAAKC,sBACPC,cAAc,EAAKD,qBACnB,EAAKA,yBAAsBnC,GAE7B,EAAK2B,gBACN,EA5iBC,EAAKxD,OAASA,EAGd,EAAKkE,WAAa,IAAI9K,GAAJ,WAClB,EAAK+K,qBACL,EAAKL,iBACL,EAAKN,eAAiBY,EAAAA,EA9B8B,CA+BrD,C,iCA6BD,SAAGC,EAA6BpF,GAC9B,OAAOtF,KAAK2K,kBAAkBD,EAAWpF,GAAU,EACpD,G,kBAaD,SAAKoF,EAA6BpF,GAChC,OAAOtF,KAAK2K,kBAAkBD,EAAWpF,GAAU,EACpD,G,iBAWD,SAAIoF,EAA6BpF,GAC/B,OAAIsF,EAAeF,GACV1K,KAAK6K,KAAKH,EAAWpF,IAErB,kDAAUoF,EAAWpF,EAE/B,G,gCAUD,SAAmBoF,GACjB,YAAkBxC,IAAdwC,GAA2BE,EAAeF,GACrC1K,KAAK8K,oBAAoBJ,IAEzB,iEAAyBA,EAEnC,G,2BAUD,SAAcA,GACZ,YAAkBxC,IAAdwC,GAA2BE,EAAeF,GACrC1K,KAAK+K,eAAeL,IAEpB,4DAAoBA,EAE9B,G,uBAUD,SAAUA,GACR,YAAkBxC,IAAdwC,GAA2BE,EAAeF,GACrC1K,KAAKgL,WAAWN,IAEhB,wDAAgBA,EAE1B,G,+BASD,SACEA,EACApF,EACAC,GAEA,GAAIqF,EAAeF,GAAY,CAC7B,IAAMxG,EAAQ,IAAIc,EAChBiG,EAAmBP,GACnBpF,EACAC,GAIF,OAFAvF,KAAKuH,QAAQnF,KAAK8B,GAClBlE,KAAKkL,YAAYhH,GACVlE,IACR,CACC,OAAO,gEAAwB0K,EAAWpF,EAAUC,EAEvD,G,yBAUD,SAAYrB,GAEe,CACvBa,EACA,QACA,UAEmBoG,SAASjH,EAAMwB,MAClC1F,KAAKoL,iBAAiBlH,IAEtB,0DAAkBA,EAErB,G,wBAUK,SACJgB,EACAmG,EACAC,EACApH,G,uJAK4B,OAHxBqH,EAAevL,KAAKwL,QAAQtG,G,SAGElF,KAAKC,iB,OASzB,OATRwL,EAAsB,EAAtBA,KAGc,MAAhBF,IACFA,EAAeG,QAAQC,IAAIN,GAAOO,MAAK,SAAAP,GACrC,OAAO,EAAKtJ,KAAK,gBAAiBsJ,EACnC,IACDrL,KAAKwL,QAAQtG,GAAOqG,G,SAEFA,E,OAGG,OAHjBM,EAAQ,EAARA,K,UAGuBH,QAAQC,IAAIN,G,QAAnCS,EAAiB,EAAjBA,KACN9L,KAAKwH,yBAAyBuE,IAAIF,EAAO,CACvC3H,MAAOA,EACP7B,OAAQ,gBACRC,OAAQwJ,EACRL,oBAAAA,EACAjD,UAAWqD,EACXvD,WAAYuD,EACZG,WAAY,GACZpD,eAAe,EACfC,eAAgB,KAElB7I,KAAK0H,uBAAuBqE,IAAIF,EAAOA,GAIvC7L,KAAKiM,MAAMJ,GAAS,CAAE3G,IAAAA,EAAKoG,YAAAA,G,gDAC5B,G,kBAeD,SAAKZ,GAAgD,QAiC5C,EAjC4C,0BAAhBwB,EAAgB,iCAAhBA,EAAgB,kBACnD,GAAItB,EAAeF,GAAY,CAC7B,IAAI1H,GAAS,EAEPmJ,EAA8B,GAG9BC,EAAWnB,EAAmBP,GAyBpC,OAvBA1K,KAAKuH,QAAUvH,KAAKuH,QAAQzG,QAAO,SAAAoD,GACjC,OAAIA,EAAMgB,MAAQkH,IAIlBC,YAAW,WACTnI,EAAMoB,SAASgH,MAAM,EAAMJ,EAC5B,GAAE,GAEHlJ,GAAS,GAELkB,EAAMqB,OACR4G,EAAQ/J,KAAK8B,IACN,GAIV,IAEDiI,EAAQ3H,SAAQ,SAAAN,GACd,EAAKqI,WAAWrI,EACjB,IAEMlB,CACR,CACC,uEAAkB0H,GAAlB,OAAgCwB,GAEnC,G,uBAGK,SAAUM,G,gJAWG,OAVbC,EAAS,EACPC,EAA4BF,EAAMlL,KAAI,YAC1C,MAAO,CACLe,OAF+D,EAApBA,OAG3CC,OAH+D,EAAZA,OAInD2F,QAAS,MACTE,GAAI,eAAF,OAAiBsE,KAEtB,I,SAEsBzM,KAAK2M,sBAAsBD,G,UAA5CE,EAAW,EAAXA,OACAC,EAAgBD,EAASE,MAAK,SAAAC,GAAC,QAAMA,EAAE7C,KAAR,KAClB,C,qBACX,IAAIpF,MAAM+H,EAAc3C,MAAOtC,S,gCAGhCgF,EACJI,MAAK,SAACC,EAAIC,GAAL,OAAaD,EAAG9E,GAAiB+E,EAAG/E,EAApC,IACL7G,KAAI,SAAAyL,GAAC,OAAIA,EAAE/J,MAAN,K,+CACT,G,qBAGD,WAGE,OAFAhD,KAAKmN,wBACLnN,KAAKoK,4BACE,sDACR,G,iCAQD,WACE,OAAOpK,KAAKqG,SAAW+G,EAAAA,CACxB,G,wBAaD,SAAWlJ,GAAkB,WACvBgB,EAAMhB,EAAMgB,IAGhB,GAAIhB,EAAMwB,OAASX,GAEjB,GACE/E,KAAKuH,QAAQzG,QACX,SAAAuM,GAAC,OAAIA,EAAE3H,OAASX,CAAf,IACD5E,OAEF,YAGG,GAAmB,OAAf+D,EAAMwB,KAAe,CAE9B,GAAI1F,KAAKuH,QAAQzG,QAAO,SAAAuM,GAAC,MAAe,OAAXA,EAAE3H,IAAN,IAAqBvF,OAC5C,OAEF+E,EAAM,IACP,MAAM,GAAIlF,KAAKsN,cAAcpJ,EAAMA,OAElC,OAGF,IAAM2H,EAAQ7L,KAAKwL,QAAQtG,GACtB2G,WAIE7L,KAAKwL,QAAQtG,GACf2G,EAAMD,MAAK,SAAAC,GACT,EAAKI,MAAMJ,YAGT,EAAKI,MAAMJ,GACb,EAAK9J,KAAK,kBAAmB,CAAC8J,IACpC,IACF,G,gCAGO,WACN7L,KAAKuN,WAAWC,iBAAiB,UAAWxN,KAAK2H,eACjD3H,KAAKuN,WAAWC,iBAAiB,SAAUxN,KAAKwJ,cAChDxJ,KAAKuN,WAAWC,iBAAiB,OAAQxN,KAAKoK,yBAC/C,G,mCAGO,WACNpK,KAAKuN,WAAWE,oBAAoB,UAAWzN,KAAK2H,eACpD3H,KAAKuN,WAAWE,oBAAoB,SAAUzN,KAAKwJ,cACnDxJ,KAAKuN,WAAWE,oBAAoB,OAAQzN,KAAKoK,yBAClD,G,oCAsGa,SACZxK,EACA2I,G,mKAaqB,OAVnBC,EAMED,EANFC,UACAnG,EAKEkG,EALFlG,OACAC,EAIEiG,EAJFjG,OACA0J,EAGEzD,EAHFyD,WACAnD,EAEEN,EAFFM,eACA4C,EACElD,EADFkD,oBAEFlD,EAAaK,eAAgB,EAC7BC,EAAe1I,OAAS,E,kBAEGH,KAAK+B,KAAKM,EAAQC,G,OAArCgG,EAAa,EAAbA,KACNvI,EAAiBH,GACjB2I,EAAaD,WAAaA,EAC1BtI,KAAK0H,uBAAuBqE,IAAIzD,EAAYE,G,KACpClG,EAAO,G,OACR,a,KAAA,GAmBA,SAnBA,KAmBA,M,cAlBoB,O,UAAMoL,GAC3B,kBACEC,EACE,EAAKpD,WAAWqD,oBACdhO,EACAoM,EACAP,GA3jBO,IAsjBb,GArjBa,GA+jBb,kBAAO7L,GAAP,I,eAXIiO,EAAiB,EAAjBA,KAaN9N,EAAiBH,GACFmE,EAAe,GAAD,eAAK8J,IAAL,OAAwBhF,KAC9CrE,SAAQ,SAAAN,GAAK,OAAI,EAAK4J,kBAAkBtF,EAAWtE,EAAtC,I,6BAKG,OADjBpD,EAAiCwB,EAAO,IAAM,CAAC,E,UACxBoL,GAC3B,kBACEC,EACE,EAAKpD,WAAWwD,gBACdnO,EACAkB,EACAkL,EACAP,GAhlBO,IA0kBb,GAzkBa,GAolBb,kBAAO7L,GAAP,I,eAZIiO,EAAAA,EAAAA,KAcN9N,EAAiBH,GACFuE,EAAW,GAAD,eAAK0J,IAAL,OAAwBhF,KAC1CrE,SAAQ,SAAAN,GAAK,OAAI,EAAK8J,cAAcxF,EAAWtE,EAAlC,I,kFAOxBqE,EAAaK,eAAgB,EAC7BC,EAAe1I,OAAS,E,0EAE3B,G,+BAoBO,SAAkBqI,EAAmBxF,GAC3ChD,KAAKkJ,qBAAqBV,EAAWxF,EAAQgG,EAC9C,G,2BAGO,SAAcR,EAAmBxF,GACvChD,KAAKkJ,qBAAqBV,EAAWxF,EAAQsG,EAC9C,G,kCASO,SACNd,EACAxF,EACA/C,GAEAD,KAAKmJ,cAAcX,EAAWxF,EAAQ/C,GAEtC,IAAMsI,EAAevI,KAAKwH,yBAAyBiB,IAAID,GAClDD,GAGLvI,KAAKiO,iBAAiB1F,EAAcvF,EACrC,G,2BAGO,SACNwF,EACAxF,EACA/C,GAEA,IAAMsI,EAAevI,KAAKwH,yBAAyBiB,IAAID,GAClDD,GAMLQ,EACER,EAAayD,WAAUzK,OAAAA,OAAAA,CAAAA,EAClByB,GACL/C,EAEH,G,8BAGO,SACNsI,EACAvF,GAEqBhD,KAAKkO,cAAc3F,EAAarE,MACrDiK,CAAanL,EACd,G,4BAQO,WAAc,WACY,MAA5BhD,KAAKqK,sBAGTrK,KAAKqK,oBAAsB+D,aAAY,kBAAWrE,EAAAA,EAAAA,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,sEAE9C,OAF8C,kBAExC4D,EAAY3N,KAAK+B,KAAK,eA/rBR,KA6rB0B,sDAI9C/B,KAAKuN,WAAWc,YAJ8B,uDAAX,GA9rBhB,KAqsBxB,G,mCAYa,SACZ3B,G,wKAEOhB,QAAQC,IAAIe,EAAQpL,KAAI,SAAAgN,GAAG,OAAI,EAAKvM,KAAKuM,EAAIjM,OAAQiM,EAAIhM,OAA9B,M,0CACnC,G,8BAGO,SAAiB4B,GACvB,GAAIA,EAAMwB,OAASX,EAAyC,CAC1D,IAAQwJ,EAAuCrK,EAAvCqK,YAAaC,EAA0BtK,EAA1BsK,UAAWC,EAAevK,EAAfuK,WAC3BzO,KAAK0O,WACRxK,EAAMgB,IACN,CAAC,8BAA+B,CAAEqJ,YAAAA,EAAaC,UAAAA,EAAWC,WAAAA,IAC1DzO,KAAKkO,cAAchK,GACnBA,EAEH,KAAyB,UAAfA,EAAMwB,KACV1F,KAAK0O,WACR,QACA,CAAC,YACD1O,KAAKkO,cAAchK,GACnBA,GAEsB,WAAfA,EAAMwB,MACV1F,KAAK0O,WACRxK,EAAMgB,IACN,CAAC,OAAQlF,KAAK2O,WAAWzK,EAAMpD,SAC/Bd,KAAKkO,cAAchK,GACnBA,EAGL,G,2BAGO,SAAcA,GAAkB,WACtC,OAAQA,EAAMwB,MACZ,KAAKX,EACH,IAAQwJ,EAAuCrK,EAAvCqK,YAAaC,EAA0BtK,EAA1BsK,UAAWC,EAAevK,EAAfuK,WAChC,OAAO,SAAAzL,GAAM,OACX,EAAK4L,KACH,CACEvM,OAAQ,8BACRkM,YAAAA,EACAC,UAAAA,EACAC,WAAAA,GAEFzL,EARS,EAUf,IAAK,QACH,OAAO,SAAAA,GACL,IAAM/B,EAAc4N,EAAAA,GAAAA,KAAe7L,EAAOvC,QAAQqO,WAClD,EAAKC,SAASC,MAAQ/N,EACtB,EAAK2N,KAAK,QAAS3N,EACpB,EACH,IAAK,SACH,OAAO,SAAA+B,GACiB,MAAlBA,EAAOxB,UACTwB,EAAOxB,SAAU,GAEnB,EAAKoN,KAAK1K,EAAMpD,OAAQ,EAAKmO,UAAUC,UAAUlM,GAClD,EACH,QACE,MAAM,IAAI8B,MAAM,2CAErB,G,kBAcO,SAAK4F,EAA6BpF,GAAmB,WAC3D,GAAgB,MAAZA,EACF,OAAOtF,KAAKmP,mBAAmBzE,GAGjC,IAAMyB,EAA8B,GAEhCiD,GAAQ,EACNhD,EAAWnB,EAAmBP,GAiBpC,OAhBA1K,KAAKuH,QAAUvH,KAAKuH,QAAQzG,QAAO,SAAAoD,GACjC,OAAIA,EAAMgB,MAAQkH,GAAYlI,EAAMoB,UAAYA,MAG5C8J,IAGJA,GAAQ,EACRjD,EAAQ/J,KAAK8B,IACN,GACR,IAEDiI,EAAQ3H,SAAQ,SAAAN,GACd,EAAKqI,WAAWrI,EACjB,IAEMlE,IACR,G,iCAcO,SAAoB0K,GAA2B,WACjDyB,EAA8B,GAClC,GAAiB,MAAbzB,EACFyB,EAAUnM,KAAKuH,QAEfvH,KAAKuH,QAAU,OACV,CACL,IAAM6E,EAAWnB,EAAmBP,GACpC1K,KAAKuH,QAAUvH,KAAKuH,QAAQzG,QAAO,SAAAoD,GACjC,OAAIA,EAAMgB,MAAQkH,IAGlBD,EAAQ/J,KAAK8B,IACN,EACR,GACF,CAMD,OAJAiI,EAAQ3H,SAAQ,SAAAN,GACd,EAAKqI,WAAWrI,EACjB,IAEMlE,IACR,G,4BAcO,SAAe0K,GACrB,IAAKA,EACH,OAAO1K,KAAKuH,QAAQpH,OAGtB,IAAMiM,EAAWnB,EAAmBP,GACpC,OAAO1K,KAAKuH,QAAQzG,QAAO,SAAAoD,GACzB,OAAOA,EAAMgB,MAAQkH,CACtB,IAAEjM,MACJ,G,wBAcO,SAAWuK,GACjB,GAAiB,MAAbA,EACF,OAAO1K,KAAKuH,QAAQjG,KAAI,SAAA4C,GAAK,OAAIA,EAAMoB,QAAV,IAG/B,IAAM8G,EAAWnB,EAAmBP,GACpC,OAAO1K,KAAKuH,QACTzG,QAAO,SAAAoD,GAAK,OAAIA,EAAMgB,MAAQkH,CAAlB,IACZ9K,KAAI,SAAA4C,GAAK,OAAIA,EAAMoB,QAAV,GACb,I,yBA/yBD,SAAkBkB,GAChB,MAAuB,kBAAZA,GAAwBA,KAAW6I,EAAAA,EACrCA,EAAAA,EAAe7I,IAIjB8I,EAAAA,EAAAA,GAAqB9I,EAC7B,K,EA3EUN,CACHqJ,EAAAA,GAm5BV,SAAe7B,EACb8B,EACAC,GACqD,IAArDC,EAAqD,uDAAV,kBAAM,CAAN,E,4IAEvCC,EAAe,EACfxN,EAAI,E,OAGG,O,kBAAMqN,I,+EAEbrN,GACSsN,IAAeC,EAAY,EAAD,K,mCAGnC,O,UAAME,EAAMD,G,WACPD,EAAY,EAAD,K,mCAGhBC,EACmB,IAAjBA,EAxBgB,IA0BZtP,KAAKwP,IAxBO,IADK,EAyBgCF,G,+EAG5D,CAED,SAASC,EAAME,GACb,OAAO,IAAIpE,SAAQ,SAAAqE,GAAO,OAAI1D,WAAW0D,EAASD,EAAxB,GAC3B,CAED,SAASnC,EAAeqC,EAAqBF,GAC3C,OAAOpE,QAAQuE,KAAK,CAClBD,EACA,IAAItE,SAAW,SAACwE,EAAGC,GAAJ,OACb9D,YAAW,kBAAM8D,EAAO,IAAIrL,MAAM,WAAvB,GAAoCgL,EADlC,KAIlB,CAED,SAAS9G,EAAuB9E,GAC9B,OAAO1D,EAAAA,EAAAA,GAAQ0D,EAAMzD,OACtB,CAED,SAAS6I,EAAmBpF,GAC1B,OAAO1D,EAAAA,EAAAA,GAAQ0D,EAAMjD,YACtB,CAmCD,SAAS8H,EACPD,EACA5E,EACAjE,GAEA,IAAMmQ,EAAqBnQ,EAAeiE,GAGpCmM,EAAiBvH,EAAWwH,WAChC,SAAAjD,GAAC,OAAIpN,EAAeoN,GAAK+C,EAx/BM,EAw/B9B,KAEqB,IAApBC,EACFvH,EAAW3I,OAAS,EAEpB2I,EAAWyH,OAAO,EAAGF,GAEvBvH,EAAW1G,KAAK8B,EACjB,CAED,SAAS0G,EACP1G,GAEA,MAAwB,kBAAVA,GAAsB,WAAYA,CACjD,CAyBK,SAAU+G,EAAmB/G,GACjC,IAAK0G,EAAe1G,GAClB,MAAM,IAAIY,MAAM,uCAElB,IA0B6B0L,EAvB7B,MACEzL,gCAJkB0L,EAAsBvM,EAAMqK,aAO9C,IANgBkC,EAAsBvM,EAAMsK,WAQ5C,UAkBYtG,KADesI,EAxBYtM,EAAMuK,YA0BtC,IAEA+B,EAAME,WAlBhB,CAED,SAASD,EACPD,GAEA,YAActI,IAAVsI,EACK,IACEzI,MAAMC,QAAQwI,GAChBA,EAAMG,KAAK,KAEXH,CAEV,C,mBC1nCD,IAAII,EAAgB,WACnB,GAAoB,kBAATC,MAAqBA,KAAM,OAAOA,KAC7C,GAAsB,kBAAXC,QAAuBA,OAAQ,OAAOA,OACjD,MAAM,IAAIhM,MAAM,kCAChB,EAEDiM,EAAOC,QAAW,WACjB,GAAIhR,KAAM,OAAOA,KAKjB,GAA0B,kBAAfiR,YAA2BA,WAAY,OAAOA,WAKzD,IACC1P,OAAO2P,eAAe3P,OAAO4P,UAAW,aAAc,CACrD1I,IAAK,WAAc,OAAOzI,IAAO,EACjCoR,cAAc,GAMf,CAJC,MAAOlH,GAGR,OAAO0G,GACP,CACD,IAEC,OAAKS,YAAmBT,GAIxB,CAND,eAKQrP,OAAO4P,UAAUE,UACxB,CACD,CA5BiB,E,kCCsBlB,IAKA,aAkDI,WACoBvK,EAChBwK,EACAC,GAYA,QAZA,IAAAA,IAAAA,EAAAA,CAAAA,GAFgB,KAAAzK,IAAAA,EAjCb,KAAA0K,QAAgD,KAChD,KAAAC,QAA2C,KAC3C,KAAAC,UAAoD,KACpD,KAAAC,OAA0C,KAC1C,KAAAC,OAA2D,KAC3D,KAAAC,SAA4C,KACnC,KAAAC,WAAajL,EAAgBiL,WAC7B,KAAAC,KAAOlL,EAAgBkL,KACvB,KAAAC,QAAUnL,EAAgBmL,QAC1B,KAAAC,OAASpL,EAAgBoL,OAKjC,KAAAC,eAAgB,EAChB,KAAAC,UAAW,EACX,KAAAC,cAAuB,GACvB,KAAAC,cAAwB,EACxB,KAAAC,eAAiB,EAIjB,KAAAC,oBAAsB,GACtB,KAAAC,kBAAoB,GACX,KAAAC,UAAgC,CAAC,EAcpB,MAAtBnB,GAC8B,kBAAvBA,GACPvJ,MAAMC,QAAQsJ,GAEdtR,KAAK0S,UAAYpB,EAEjBC,EAAUD,EAEdtR,KAAKuR,QAAUoB,EAAoBpB,IAC9BvR,KAAKuR,QAAQnL,cAAe,CAC7B,GAAyB,qBAAdgB,UAGP,MAAM,IAAItC,MACN,mFAHJ9E,KAAKuR,QAAQnL,cAAgBgB,SAOpC,CACDpH,KAAK4S,kBACR,CAkXL,OAhXIrR,OAAAA,eAAWsF,EAAAA,UAAA,aAAU,C,IAArB,WACI,OAAO7G,KAAK6S,oBAAsB,MACrC,E,IAED,SAAsBC,GAClB9S,KAAK6S,mBAAqBC,EACtB9S,KAAK4G,KACL5G,KAAK4G,GAAGkM,WAAaA,EAE5B,E,gCAEDvR,OAAAA,eAAWsF,EAAAA,UAAA,iBAAc,C,IAAzB,WACI,IAAIkM,EAAM/S,KAAK4G,GAAK5G,KAAK4G,GAAGoM,eAAiB,EACzCC,GAAmB,EAevB,OAdAjT,KAAKoS,cAAc5N,SAAQ,SAAAqB,GACvB,IAAMqN,EA+WlB,SAA2BrN,GACvB,MAAoB,kBAATA,EAEA,EAAIA,EAAK1F,OACT0F,aAAgBsN,YAChBtN,EAAKqN,WACLrN,aAAgBuN,KAChBvN,EAAKwN,UAEZ,CAEP,CA1X8BC,CAAkBzN,GACnB,MAAdqN,EACAH,GAAOG,EAEPD,GAAmB,CAE1B,IACGA,GACAjT,KAAKuT,SACD,yGAIDR,CACV,E,gCAEDxR,OAAAA,eAAWsF,EAAAA,UAAA,aAAU,C,IAArB,WACI,OAAO7G,KAAK4G,GAAK5G,KAAK4G,GAAG4M,WAAaxT,KAAKuS,mBAC9C,E,gCAEDhR,OAAAA,eAAWsF,EAAAA,UAAA,WAAQ,C,IAAnB,WACI,OAAO7G,KAAK4G,GAAK5G,KAAK4G,GAAGF,SAAW1G,KAAKwS,iBAC5C,E,gCAEDjR,OAAAA,eAAWsF,EAAAA,UAAA,aAAU,C,IAArB,WACI,OAAO7G,KAAKmS,SAAWtL,EAAgBoL,OAASpL,EAAgBkL,IACnE,E,gCAEMlL,EAAAA,UAAAA,MAAP,SAAa4M,EAAeC,GACxB1T,KAAK2T,cAAcF,EAAMC,GACzB1T,KAAK4T,WACL5T,KAAKuT,SAAS,0CACjB,EAEM1M,EAAAA,UAAAA,KAAP,SAAYhB,GACR,GAAI7F,KAAKmS,SACL,MAAM,IAAIrN,MAAM,oDACT9E,KAAK4G,IAAM5G,KAAK4G,GAAGiN,aAAe7T,KAAK+R,KAC9C/R,KAAK4G,GAAG7E,KAAK8D,GAEb7F,KAAKoS,cAAchQ,KAAKyD,EAE/B,EAEMgB,EAAAA,UAAAA,UAAP,WACI,GAAI7G,KAAKmS,SACL,MAAM,IAAIrN,MACN,kEAGR9E,KAAK2T,cAAc,IAAM,+BACzB3T,KAAK8T,iBAAY5L,EACpB,EAUMrB,EAAAA,UAAAA,iBAAP,SACInB,EACAJ,GAEKtF,KAAKyS,UAAU/M,KAChB1F,KAAKyS,UAAU/M,GAAQ,IAE3B1F,KAAKyS,UAAU/M,GAAMtD,KAAKkD,EAC7B,EAEMuB,EAAAA,UAAAA,cAAP,SAAqB3C,GACjB,OAAOlE,KAAK+T,oBAAoB7P,EAAMwB,KAAMxB,EAC/C,EAUM2C,EAAAA,UAAAA,oBAAP,SACInB,EACAJ,GAEItF,KAAKyS,UAAU/M,KACf1F,KAAKyS,UAAU/M,GAAQ1F,KAAKyS,UAAU/M,GAAM5E,QACxC,SAAAkT,GAAK,OAAAA,IAAM1O,CAAQ,IAG9B,EAEOuB,EAAAA,UAAAA,iBAAR,sBACI,IAAI7G,KAAKmS,SAAT,CAGM,mBAAE8B,EAAAA,EAAAA,eAAgB7N,EAAAA,EAAAA,cACxBpG,KAAKuT,SAAS,4BAA4BvT,KAAK8G,IAAG,KAClD,IAAMF,EAAgB,IAAIR,EAAcpG,KAAK8G,IAAK9G,KAAK0S,WACvD9L,EAAG4K,QAAU,SAAAtN,GAAS,SAAK4P,YAAY5P,EAAM,EAC7C0C,EAAG6K,QAAU,SAAAvN,GAAS,SAAKgQ,YAAYhQ,EAAM,EAC7C0C,EAAG8K,UAAY,SAAAxN,GAAS,SAAKyD,cAAczD,EAAM,EACjD0C,EAAG+K,OAAS,SAAAzN,GAAS,SAAKiQ,WAAWjQ,EAAM,EAC3ClE,KAAKoU,iBAAmB/H,YAAW,WAG/BgI,EAAKC,sBACLD,EAAKV,gBACLU,EAAKP,iBAAY5L,EACpB,GAAE+L,GACHjU,KAAK4G,GAAKA,CAfT,CAgBJ,EAEOC,EAAAA,UAAAA,WAAR,SAAmB3C,GAAnB,WACI,GAAKlE,KAAK4G,KAAM5G,KAAKmS,SAArB,CAGQ,IAAAoC,EAAA,aAAAA,kBACRvU,KAAKuT,SAAS,qBACiB,MAA3BvT,KAAK6S,mBACL7S,KAAK4G,GAAGkM,WAAa9S,KAAK6S,mBAE1B7S,KAAK6S,mBAAqB7S,KAAK4G,GAAGkM,WAEtC9S,KAAKsU,sBACDtU,KAAKkS,cACLlS,KAAK+T,oBAAoB,SAAU7P,IAEnClE,KAAK+T,oBAAoB,OAAQ7P,GACjClE,KAAKkS,eAAgB,GAEzBlS,KAAKoS,cAAc5N,SAAQ,SAAAoD,GAAW,SAAK7F,KAAK6F,EAAQ,IACxD5H,KAAKoS,cAAgB,GACrBpS,KAAKwU,kBAAoBnI,YAAW,WAChCgI,EAAKI,uBACLJ,EAAKhC,cAAgB,EACrBgC,EAAK/B,eAAiB,EACtB,IAAMoC,EAAYH,EAAoB,IAAQ,EAC9CF,EAAKd,SACD,+BAA+BmB,EAA/B,4CAGP,GAAEH,EA1BF,CA2BJ,EAEO1N,EAAAA,UAAAA,cAAR,SAAsB3C,GACdlE,KAAKmS,UAGTnS,KAAK+T,oBAAoB,UAAW7P,EACvC,EAEO2C,EAAAA,UAAAA,YAAR,SAAoB3C,GAApB,WACI,IAAIlE,KAAKmS,SAAT,CAGM,mBAAEwC,EAAAA,EAAAA,qBAAsBC,EAAAA,EAAAA,gBAS9B,GARA5U,KAAKsU,sBACLtU,KAAKyU,uBACDzU,KAAK4G,KACL5G,KAAKuS,oBAAsBvS,KAAK4G,GAAG4M,WACnCxT,KAAKwS,kBAAoBxS,KAAK4G,GAAGF,SACjC1G,KAAK2T,iBAET3T,KAAK+T,oBAAoB,OAAQ7P,GAC7BlE,KAAKsS,gBAAkBqC,EACvB3U,KAAK6U,iBACD3Q,EACAlE,KAAK8U,yCAHb,CAOA,IAAMC,GAAiB7Q,GAAS0Q,EAAgB1Q,GACnB,mBAAlB6Q,EACP/U,KAAKgV,oBACDD,EACA7Q,EApRZ,mEAwRQ6Q,EAAcnJ,MAAK,SAAAqJ,GACXZ,EAAKlC,UAGTkC,EAAKW,oBACDC,EACA/Q,EA5RhB,qEA+RS,GAlBJ,CAhBA,CAoCJ,EAEO2C,EAAAA,UAAAA,YAAR,SAAoB3C,GAChBlE,KAAK+T,oBAAoB,QAAS7P,GAClClE,KAAKuT,SAAS,kCACjB,EAEO1M,EAAAA,UAAAA,oBAAR,SACIkO,EACA7Q,EACAgR,GAEIH,EACA/U,KAAKmV,wBAELnV,KAAK6U,iBAAiB3Q,EAAOgR,EAEpC,EAEOrO,EAAAA,UAAAA,sBAAR,sBACU,eACFuO,EAAAA,EAAAA,kBACAC,EAAAA,EAAAA,kBACAC,EAAAA,EAAAA,uBAEJtV,KAAKsS,iBACL,IAAMiD,EAAYvV,KAAKqS,cACvBrS,KAAKqS,cAAgBhS,KAAKC,IACtB8U,EACA/U,KAAKwP,IACD7P,KAAKqS,cAAgBiD,EACrBD,IAGRhJ,YAAW,WAAM,SAAKuG,kBAAkB,GAAE2C,GAC1C,IAAMC,EAAoBD,EAAY,IAAQ,EAC9CvV,KAAKuT,SACD,uCAAuCiC,EAAgB,YAE9D,EAEO3O,EAAAA,UAAAA,iBAAR,SACI3C,EACAuR,GAEAzV,KAAKuT,SAASkC,GACdzV,KAAK4T,WACD1P,GACAlE,KAAK+T,oBAAoB,QAAS7P,EAEzC,EAEO2C,EAAAA,UAAAA,SAAR,WACI7G,KAAKmS,UAAW,EAChBnS,KAAK0V,mBACL1V,KAAKoS,cAAgB,GACrBpS,KAAK2T,eACR,EAEO9M,EAAAA,UAAAA,cAAR,SAAsB8O,EAAoBjC,GACjC1T,KAAK4G,KAMV5G,KAAK4G,GAAG6K,QAAUhH,EAClBzK,KAAK4G,GAAG4K,QAAU/G,EAClBzK,KAAK4G,GAAG8K,UAAYjH,EACpBzK,KAAK4G,GAAG+K,OAASlH,EACjBzK,KAAK4G,GAAGgP,MAAMD,EAAWjC,GACzB1T,KAAK4G,QAAKsB,EACb,EAEOrB,EAAAA,UAAAA,iBAAR,WACI7G,KAAKsU,sBACLtU,KAAKyU,sBACR,EAEO5N,EAAAA,UAAAA,oBAAR,WACiC,MAAzB7G,KAAKoU,mBACLyB,aAAa7V,KAAKoU,kBAClBpU,KAAKoU,sBAAmBlM,EAE/B,EAEOrB,EAAAA,UAAAA,qBAAR,WACkC,MAA1B7G,KAAKwU,oBACLqB,aAAa7V,KAAKwU,mBAClBxU,KAAKwU,uBAAoBtM,EAEhC,EAEOrB,EAAAA,UAAAA,oBAAR,SAA4BnB,EAAcxB,GAA1C,WACI,OAAQwB,GACJ,IAAK,QACG1F,KAAKwR,SACLxR,KAAKwR,QAAQtN,GAEjB,MACJ,IAAK,QACGlE,KAAKyR,SACLzR,KAAKyR,QAAQvN,GAEjB,MACJ,IAAK,UACGlE,KAAK0R,WACL1R,KAAK0R,UAAUxN,GAEnB,MACJ,IAAK,OACGlE,KAAK2R,QACL3R,KAAK2R,OAAOzN,GAEhB,MACJ,IAAK,OACGlE,KAAK4R,QACL5R,KAAK4R,OAAO1N,GAEhB,MACJ,IAAK,SACGlE,KAAK6R,UACL7R,KAAK6R,SAAS3N,GAS1B,OALIwB,KAAQ1F,KAAKyS,WACbzS,KAAKyS,UAAU/M,GACVoQ,QACAtR,SAAQ,SAAAc,GAAY,SAAKyQ,aAAazQ,EAAUpB,EAAM,KAEvDA,IAAWA,EAAgB8R,gBACtC,EAEOnP,EAAAA,UAAAA,aAAR,SACIvB,EACApB,GAEwB,oBAAboB,EACPA,EAAS2Q,KAAKjW,KAAMkE,GAEpBoB,EAAS4Q,YAAYD,KAAKjW,KAAMkE,EAEvC,EAEO2C,EAAAA,UAAAA,SAAR,SAAiBe,GACT5H,KAAKuR,QAAQ4E,OAEblM,QAAQ5I,IAAIuG,EAEnB,EAEOf,EAAAA,UAAAA,kCAAR,WACY,IAiCGuP,EAjCHzB,EAAA,aAAAA,qBACR,MAAO,6BAA6BA,EAAoB,KAgC7CyB,EA/BP,WAgCK,IA/BLzB,EA+BSyB,EAAOA,EAAC,KA9BpB,yBACJ,EA5bsBvP,EAAAA,gBAAqC,CACxD0N,kBAAmB,IACnBN,eAAgB,IAChBkC,OAAO,EACPf,kBAAmB,IACnBC,kBAAmB,IACnBV,qBAAsBjT,OAAO2U,kBAC7Bf,uBAAwB,IACxBV,gBAAiB,WAAM,QAAI,EAC3BxO,mBAAe8B,GAGIrB,EAAAA,WAAa,EACbA,EAAAA,KAAO,EACPA,EAAAA,QAAU,EACVA,EAAAA,OAAS,EA8apC,CAAC,CA9bD,GAgcA,SAAS8L,EAAoBpB,GACzB,IAAMvO,EAAc,CAAC,EAQrB,OAPAzB,OAAO+U,KAAKzP,EAAgB0P,iBAAiB/R,SAAQ,SAAAE,GACjD,IAAM8R,EAASjF,EAAgB7M,GAC/B1B,EAAO0B,QACOwD,IAAVsO,EACO3P,EAAgB0P,gBAAwB7R,GACzC8R,CACb,IACMxT,CACV,CAmBD,SAASyH,IAER,C,IA/doB5D,C,uBCjCrB,IAAI4P,EACJ,GAA0B,kBAAfxF,WACVwF,EAAcxF,gBAEd,IACCwF,EAActP,EAAQ,KAKtB,CAJC,MAAO+C,GACR,CAHD,QAKC,GADKuM,GAAiC,qBAAX3F,SAA0B2F,EAAc3F,SAC9D2F,EAAe,MAAM,IAAI3R,MAAM,kCACpC,CAGF,IAAI4R,EAAkBD,EAAYrP,WAAaqP,EAAYE,aACvDC,EAAoBzP,EAAQ,MAMhC,SAAS0P,EAAaC,EAAKpE,GAiB1B,OAdIA,EACe,IAAIgE,EAAgBI,EAAKpE,GAGzB,IAAIgE,EAAgBI,EAWvC,CACGJ,GACH,CAAC,aAAc,OAAQ,UAAW,UAAUlS,SAAQ,SAASuS,GAC5DxV,OAAO2P,eAAe2F,EAAcE,EAAM,CACzCtO,IAAK,WAAa,OAAOiO,EAAgBK,EAAQ,GAElD,IAMFhG,EAAOC,QAAU,CACb,aAAiB0F,EAAkBG,EAAe,KAClD,QAAiBD,E,uBCpDrB7F,EAAOC,QAAU,EAAjBD,MAAAA,O","sources":["../node_modules/alchemy-sdk/src/internal/websocket-backfiller.ts","../node_modules/alchemy-sdk/src/internal/internal-types.ts","../node_modules/alchemy-sdk/src/api/alchemy-websocket-provider.ts","../node_modules/es5-ext/global.js","../node_modules/sturdy-websocket/src/index.ts","../node_modules/websocket/lib/browser.js","../node_modules/websocket/lib/version.js"],"sourcesContent":["import { fromHex, toHex } from '../api/util';\nimport { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: just fire off each send() separately since we're no longer batching:\n    // TODO: handle errors\n    const batchedBlockHeads = await this.provider.sendBatch(batchParts);\n    const blockHeads = batchedBlockHeads.reduce(\n      (acc, batch) => acc.concat(batch),\n      []\n    );\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import {\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent\n} from './websocket-backfiller';\nimport { EventType, Filter, Listener } from '@ethersproject/abstract-provider';\n\n/** This file contains internal types used by the SDK and are not exposed to the end user. */\n\ntype JsonRpcId = string | number | null;\n\n/**\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\n * ethers events.\n */\nexport const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE =\n  'alchemy-pending-transactions';\n\nexport interface JsonRpcRequest {\n  jsonrpc: '2.0';\n  method: string;\n  params?: any[];\n  id?: JsonRpcId;\n}\n\nexport interface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\nexport interface JsonRpcResponse<T = any> {\n  jsonrpc: '2.0';\n  result?: T;\n  error?: JsonRpcError;\n  id: JsonRpcId;\n}\n\ninterface JsonRpcError<T = any> {\n  code: number;\n  message: string;\n  data?: T;\n}\n\nexport interface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\nexport interface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;\nexport type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];\n\n/**\n * DO NOT MODIFY.\n *\n * Event class copied directly over from ethers.js's `BaseProvider` class.\n *\n * This class is used to represent events and their corresponding listeners. The\n * SDK needs to extend this class in order to support Alchemy's custom\n * Subscription API types. The original class is not exported by ethers. Minimal\n * changes have been made in order to get TS to compile.\n */\nexport class Event {\n  readonly listener: Listener;\n  readonly once: boolean;\n  readonly tag: string;\n\n  _lastBlockNumber: number;\n  _inflight: boolean;\n\n  constructor(tag: string, listener: Listener, once: boolean) {\n    this.listener = listener;\n    this.tag = tag;\n    this.once = once;\n    this._lastBlockNumber = -2;\n    this._inflight = false;\n  }\n\n  get event(): EventType {\n    switch (this.type) {\n      case 'tx':\n        return this.hash!;\n      case 'filter':\n        return this.filter!;\n      default:\n        return this.tag;\n    }\n  }\n\n  get type(): string {\n    return this.tag.split(':')[0];\n  }\n\n  get hash(): string {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'tx') {\n      throw new Error('Not a transaction event');\n    }\n    return comps[1];\n  }\n\n  get filter(): Filter {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'filter') {\n      throw new Error('Not a transaction event');\n    }\n    const address = comps[1];\n\n    const topics = deserializeTopics(comps[2]);\n    const filter: Filter = {};\n\n    if (topics.length > 0) {\n      filter.topics = topics;\n    }\n    if (address && address !== '*') {\n      filter.address = address;\n    }\n\n    return filter;\n  }\n\n  pollable(): boolean {\n    const PollableEvents = ['block', 'network', 'pending', 'poll'];\n    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n  }\n}\n\n/**\n * Wrapper class around the ethers `Event` class in order to add support for\n * Alchemy's custom subscriptions types.\n *\n * The getters on this class deserialize the event tag generated by\n * {@link getAlchemyEventTag} into the original fields passed into the event.\n */\nexport class EthersEvent extends Event {\n  /**\n   * Converts the event tag into the original `fromAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get fromAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return deserializeAddressField(comps[1]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `toAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get toAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[2] && comps[2] !== '*') {\n      return deserializeAddressField(comps[2]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `hashesOnly` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get hashesOnly(): boolean | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[3] && comps[3] !== '*') {\n      return comps[3] === 'true';\n    } else {\n      return undefined;\n    }\n  }\n}\n\nexport interface SubscriptionEvent<T = any> {\n  jsonrpc: '2.0';\n  method: 'eth_subscription';\n  params: {\n    subscription: string;\n    result: T;\n  };\n}\n\nfunction deserializeTopics(data: string): any {\n  if (data === '') {\n    return [];\n  }\n\n  return data.split(/&/g).map(topic => {\n    if (topic === '') {\n      return [];\n    }\n\n    const comps = topic.split('|').map(topic => {\n      return topic === 'null' ? null : topic;\n    });\n\n    return comps.length === 1 ? comps[0] : comps;\n  });\n}\n\nfunction deserializeAddressField(data: string): string | string[] | undefined {\n  if (data === '') {\n    return undefined;\n  }\n\n  const addresses = data.split('|');\n  return addresses.length === 1 ? addresses[0] : addresses;\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { Listener } from '@ethersproject/abstract-provider';\nimport {\n  AlchemyEventType,\n  AlchemyPendingTransactionsEventFilter\n} from '../types/types';\nimport {\n  BatchPart,\n  dedupeLogs,\n  dedupeNewHeads,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  throwIfCancelled,\n  WebsocketBackfiller\n} from '../internal/websocket-backfiller';\nimport { fromHex } from './util';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { VERSION } from '../version';\nimport {\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  EthersEvent,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  LogsSubscription,\n  NewHeadsSubscription,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  VirtualSubscription,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\nimport { AlchemyConfig } from './alchemy-config';\nimport {\n  getNetwork as getNetworkFromEthers,\n  Networkish\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [\n      ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n      'block',\n      'filter'\n    ];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    const response = await this.sendBatchConcurrently(payload);\n    const errorResponse = response.find(r => !!r.error);\n    if (errorResponse) {\n      throw new Error(errorResponse.error!.message);\n    }\n    // The ids are ascending numbers because that's what Payload Factories do.\n    return response\n      .sort((r1, r2) => (r1.id as number) - (r2.id as number))\n      .map(r => r.result);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(\n          e => e.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE\n        ).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<JsonRpcResponse[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        ['alchemy_pendingTransactions', { fromAddress, toAddress, hashesOnly }],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        const { fromAddress, toAddress, hashesOnly } = event;\n        return result =>\n          this.emit(\n            {\n              method: 'alchemy_pendingTransactions',\n              fromAddress,\n              toAddress,\n              hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n\nfunction isAlchemyEvent(\n  event: AlchemyEventType\n): event is AlchemyPendingTransactionsEventFilter {\n  return typeof event === 'object' && 'method' in event;\n}\n\n/**\n * Creates a string representation of an `alchemy_pendingTransaction`\n * subscription filter that is compatible with the ethers implementation of\n * `getEventTag()`. The method is not an exported function in ethers, which is\n * why the SDK has its own implementation.\n *\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\n *\n * @example\n *   ```js\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\n *   const eventTag =  getAlchemyEventTag(\n *   {\n *     \"method\": \"alchemy_pendingTransaction\",\n *     \"fromAddress\": \"0xABC\",\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\n *     \"hashesOnly: true\n *   });\n *   ```;\n *\n * @param event\n * @internal\n */\nexport function getAlchemyEventTag(event: AlchemyEventType): string {\n  if (!isAlchemyEvent(event)) {\n    throw new Error('Event tag requires AlchemyEventType');\n  }\n  const fromAddress = serializeAddressField(event.fromAddress);\n  const toAddress = serializeAddressField(event.toAddress);\n  const hashesOnly = serializeBooleanField(event.hashesOnly);\n  return (\n    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE +\n    ':' +\n    fromAddress +\n    ':' +\n    toAddress +\n    ':' +\n    hashesOnly\n  );\n}\n\nfunction serializeAddressField(\n  field: string | Array<string> | undefined\n): string {\n  if (field === undefined) {\n    return '*';\n  } else if (Array.isArray(field)) {\n    return field.join('|');\n  } else {\n    return field;\n  }\n}\n\nfunction serializeBooleanField(field: boolean | undefined): string | undefined {\n  if (field === undefined) {\n    return '*';\n  } else {\n    return field.toString();\n  }\n}\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["WebsocketBackfiller","provider","maxBackfillBlocks","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","this","getBlockNumber","toBlockNumber","length","getHeadEventsInRange","Math","max","lastSeenBlockNumber","fromHex","number","minBlockNumber","getReorgHeads","reorgHeads","intermediateHeads","filter","previousLogs","getLogsInRange","blockNumber","getCommonAncestor","commonAncestor","removedLogs","log","map","Object","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","newMax","send","blockNumberHex","toBlockExclusive","batchParts","i","push","method","params","toHex","sendBatch","batchedBlockHeads","blockHeads","reduce","acc","batch","concat","toNewHeadsEvent","result","oldEvent","getBlockByNumber","blockHead","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","items","getKey","keysSeen","Set","forEach","item","key","has","add","CANCELLED","Error","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","EthersEvent","comps","tag","split","deserializeAddressField","Event","listener","once","_lastBlockNumber","_inflight","type","address","topics","data","topic","deserializeTopics","indexOf","addresses","AlchemyWebSocketProvider","config","wsConstructor","apiKey","AlchemyProvider","alchemyNetwork","network","connection","protocol","VERSION","ws","SturdyWebSocket","url","_a","process","versions","node","require","WebSocket","ethersNetwork","EthersNetwork","_events","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","message","JSON","parse","Array","isArray","jsonrpc","undefined","id","isResponse","isSubscriptionEvent","physicalId","subscription","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","handleReopen","clear","cancelled","cancel","makeCancelToken","cancelBackfill","values","__awaiter","resubscribeAndBackfill","console","error","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","noop","eventName","_addEventListener","isAlchemyEvent","_off","_removeAllListeners","_listenerCount","_listeners","getAlchemyEventTag","_startEvent","includes","customStartEvent","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","then","subId","resolvedParams","set","sentEvents","_subs","args","stopped","eventTag","setTimeout","apply","_stopEvent","parts","nextId","payload","sendBatchConcurrently","response","errorResponse","find","r","sort","r1","r2","removeSocketListeners","DEFAULT_ALCHEMY_API_KEY","e","listenerCount","_websocket","addEventListener","removeEventListener","withBackoffRetries","withTimeout","getNewHeadsBackfill","backfillEvents","emitNewHeadsEvent","getLogsBackfill","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","setInterval","reconnect","req","fromAddress","toAddress","hashesOnly","_subscribe","_getFilter","emit","BigNumber","toNumber","_emitted","block","formatter","filterLog","removeAllListeners","found","CustomNetworks","getNetworkFromEthers","WebSocketProvider","f","retryCount","shouldRetry","nextWaitTime","delay","min","ms","resolve","promise","race","_","reject","currentBlockNumber","firstGoodIndex","findIndex","splice","field","serializeAddressField","toString","join","naiveFallback","self","window","module","exports","globalThis","defineProperty","prototype","configurable","__global__","protocolsOrOptions","options","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","listeners","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","code","reason","disposeSocket","shutdown","readyState","handleClose","dispatchEventOfType","l","connectTimeout","handleError","handleOpen","connectTimeoutId","_this","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","close","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","s","POSITIVE_INFINITY","keys","DEFAULT_OPTIONS","value","_globalThis","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","prop"],"sourceRoot":""}